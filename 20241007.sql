-- 학과 테이블 DNAME의 고유 인덱스 생성
CREATE UNIQUE INDEX IDX_DEPT_DEPARTMENT ON DEPARTMENT(DNAME);
SELECT /*+ INDEX(d IDX_DEPT_DEPARTMENT) */ * FROM DEPARTMENT d ;
SELECT * FROM DEPARTMENT d ;

DROP INDEX IDX_DEPT_DEPARTMENT;

SELECT /*+ INDEX_DESC(DEPARTMENT_PK) */ * FROM DEPARTMENT d ;

-- STUDENT 테이블의 BIRTHDATE에 비고유 인덱스 생성
CREATE INDEX IDX_STUD_BIRTHDATE ON STUDENT(BIRTHDATE);
SELECT /*+ INDEX(s IDX_STUD_BIRTHDATE DESC) */ * FROM STUDENT s ;

-- STUDENT 테이블의 DEPTNO, GRADE에 결합 인덱스 생성
SELECT DISTINCT GRADE, DEPTNO FROM STUDENT;
CREATE INDEX IDX_STUD_DEPTNO_GRADE ON STUDENT(DEPTNO, GRADE DESC);

SELECT /*+ INDEX (s IDX_STUD_DEPTNO_GRADE DESC) */ * FROM STUDENT s;

-- 뷰 (공간 할당을 안 함)
SELECT * FROM  STUDENT s ;

CREATE VIEW VIEW_STUD AS
SELECT STUDNO, NAME, DEPTNO FROM STUDENT;

SELECT * FROM VIEW_STUD;

SELECT DEPTNO, COUNT(*)
FROM VIEW_STUD
WHERE DEPTNO <> 201
GROUP BY DEPTNO;

INSERT INTO VIEW_STUD VALUES (12345, '홍길동', NULL);
SELECT * FROM STUDENT s ;
-- 뷰에 INSERT를 하면 TABLE에도 같이 추가된다

-- 뷰의 변경은 ALTER로 하지 않고 REPLACE로 한다
-- REPLACE는 단독으로 쓸 수 없다
CREATE OR REPLACE VIEW VIEW_STUD AS
SELECT STUDNO, NAME, USERID, DEPTNO FROM STUDENT;

SELECT * FROM VIEW_STUD;

-- 서브쿼리가 틀린 경우 에러가 나지만 뷰 강제 생성 가능
CREATE FORCE VIEW VIEW_STUD2 AS
SELECT * FROM STUDEW;

SELECT * FROM VIEW_STUD2;

-- 복합 뷰 : 두 개 이상의 테이블로 구성한 뷰
-- 단순 뷰를 만들 때보다 제약 조건이 조금 더 있음

-- 학번, 이름, 학과 번호, 학과 이름으로 VIEW_STUD_DEPT라는 뷰 생성
CREATE VIEW VIEW_STUD_DEPT AS
SELECT STUDNO, NAME, DEPTNO, DNAME
FROM STUDENT s NATURAL JOIN DEPARTMENT d;

SELECT * FROM VIEW_STUD_DEPT;

-- 11111, 고길동, 101, 컴퓨터공학과 학생 추가
INSERT INTO VIEW_STUD_DEPT VALUES(11111, '고길동', 101, '컴퓨터공학과');

-- 위 쿼리는 수행되지 않는다 : 복합 뷰는 DML 처리가 안 된다

-- 함수나 표현식에 의해 정의된 컬럼은 별도로 이름을 명시해야 한다(AS)
-- 학과별 인원 수를 조회하여 VIEW_STUD_DEPT2라는 이름의 뷰 생성
CREATE VIEW VIEW_STUD_DEPT2 AS
SELECT DEPTNO, COUNT(*)
FROM STUDENT
GROUP BY DEPTNO
ORDER BY 1;
-- 위처럼 COUNT는 함수이기 때문에 별칭을 꼭 줘야 한다

CREATE VIEW VIEW_STUD_DEPT2(A, B) AS
SELECT DEPTNO, COUNT(*)
FROM STUDENT
GROUP BY DEPTNO
ORDER BY 1;

SELECT * FROM VIEW_STUD_DEPT2;

-- 인라인 뷰 (FROM 절 서브쿼리)
SELECT * FROM BOARD;

DROP SEQUENCE SEQ_BOARD;
CREATE SEQUENCE SEQ_BOARD;

INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER) 
	VALUES (SEQ_BOARD.NEXTVAL, '제목' || SEQ_BOARD.CURRVAL, '내용', '작성자');

INSERT INTO BOARD (NO, TITLE, CONTENT, WRITER)
	SELECT SEQ_BOARD.NEXTVAL, TITLE, CONTENT, WRITER FROM BOARD;
	
-- 한 페이지에 10개씩 나오도록
SELECT * FROM (
	SELECT ROWNUM RN, A.*
	FROM  (
		SELECT B.*
		FROM BOARD B
		--WHERE ROWNUM <= 10
		ORDER BY 1 DESC
	) A
)
WHERE ROWNUM <= 10 AND RN > (1 - 1) * 10;

-- 방법 1
SELECT * FROM (
	SELECT /*+ INDEX_DESC(B BOARD_PK) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
);

-- 방법 2
WITH A AS (
	SELECT /*+ INDEX_DESC(B BOARD_PK) */ B.*, ROWNUM RN 
	FROM BOARD B
	WHERE NO > 0
)
SELECT * 
FROM A
WHERE ROWNUM <= 20
AND RN > 10;

-- 뷰에 대한 무결성 제약 조건은 테이블에 정의된 무결성 제약 조건을 그대로 따라간다


-- FILE SYSTEM
-- FILE의 권한

--			Read	Write	eXecute			0~7까지의 값을 가짐
-- owner	 1		  1		   1
-- guest	 0		  0		   0
-- group	 1		  0		   1

-- 기본값은 chmod 704, 705

-- SYSTEM 계정에서 SAMPLE에게 HR을 조회할 권한 부여 작업 필수
SELECT * FROM HR.EMPLOYEES;

-- 동의어
-- ex) DUAL
SELECT SYSDATE FROM DUAL;
-- 원래 형태는
SELECT * FROM SYS.DUAL; 

-- 동의어의 종류
-- 1. 전용 동의어 : 객체 접근 권한을 부여받은 사용자가 정의한 동의어
SELECT * FROM HR.EMPLOYEES;

CREATE SYNONYM EMP FOR HR.EMPLOYEES; 
SELECT * FROM EMP;

-- 2. 공용 동의어 : DBA 권한을 가진 사용자만이 생성 (PUBLIC을 붙임)
CREATE PUBLIC SYNONYM STU FOR SAMPLE.STUDENT;
SELECT * FROM STU;


-- 데이터 사전
-- 접두어 : USER_ ALL_ DBA_
SELECT * FROM ALL_TABLES WHERE OWNER = 'SAMPLE';

SELECT * FROM USER_TAB_COLUMNS WHERE TABLE_NAME = 'BOARD';

SELECT * FROM USER_CONSTRAINTS;